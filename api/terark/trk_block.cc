//  Copyright (c) 2011-present, Facebook, Inc.  All rights reserved.
//  This source code is licensed under the BSD-style license found in the
//  LICENSE file in the root directory of this source tree. An additional grant
//  of patent rights can be found in the PATENTS file in the same directory.
//
// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file. See the AUTHORS file for names of contributors.
//
// Decodes the blocks generated by block_builder.cc.

#include <algorithm>
#include <string>
#include <unordered_map>
#include <vector>

#include "port/port.h"
#include "port/stack_trace.h"
#include "rocksdb/comparator.h"
#include "util/coding.h"
#include "util/logging.h"
#include "util/perf_context_imp.h"

#include "trk_block.h"

namespace rocksdb {

	static inline const char* DecodeEntry(const char* p, const char* limit,
										  uint32_t* key_length,
										  uint32_t* value_length) {
		if (limit - p < 3) return nullptr;
		if ((p = GetVarint32Ptr(p, limit, key_length)) == nullptr) return nullptr;
		if ((p = GetVarint32Ptr(p, limit, value_length)) == nullptr) return nullptr;
		if (static_cast<uint32_t>(limit - p) < (*key_length + *value_length)) {
			return nullptr;
		}
		return p;
	}

	void TerarkBlockIter::Next() {
		assert(Valid());
		ParseNextKey();
	}

	void TerarkBlockIter::Prev() {
		abort(); // not supported
	}

	void TerarkBlockIter::Seek(const Slice& target) {
		if (data_ == nullptr) {  // Not init yet
			return;
		}
		value_ = Slice(data_, 0);
		while (true) {
			if (!ParseNextKey() || Compare(key_.GetKey(), target) >= 0) {
				return;
			}
		}
	}

	void TerarkBlockIter::SeekForPrev(const Slice& target) {
		abort(); // not supported
	}

	void TerarkBlockIter::SeekToFirst() {
		if (data_ == nullptr) {  // Not init yet
			return;
		}
		value_ = Slice(data_, 0);
		ParseNextKey();
	}

	void TerarkBlockIter::SeekToLast() {
		abort(); // not supported
	}

	void TerarkBlockIter::CorruptionError() {
		current_ = size_;
		status_ = Status::Corruption("bad entry in block");
		key_.Clear();
		value_.clear();
	}

	bool TerarkBlockIter::ParseNextKey() {
		current_ = NextEntryOffset();
		const char* p = data_ + current_;
		const char* limit = data_ + size_;
		if (p >= limit) {
			// No more entries to return.  Mark as invalid.
			current_ = size_;
			return false;
		}
		// Decode next entry
		uint32_t key_length, value_length;
		p = DecodeEntry(p, limit, &key_length, &value_length);
		if (p == nullptr || key_length < 1) {
			CorruptionError();
			return false;
		} else {
			key_.SetKey(Slice(p, key_length), false /* copy */);
			value_ = Slice(p + key_length, value_length);
			return true;
		}
	}

	TerarkBlock::TerarkBlock(TerarkBlockContents&& contents)
		: contents_(std::move(contents)),
		  data_(contents_.data.data()),
		  size_(contents_.data.size()) {
		if (size_ < sizeof(uint32_t)) {
			size_ = 0;  // Error marker
		}
	}

	Iterator* TerarkBlock::NewIterator(const Comparator* cmp) {
		if (size_ < 2 * sizeof(uint32_t)) {
			return nullptr;
		} else {
			return new TerarkBlockIter(cmp, data_, size_);
		}
	}

}  // namespace rocksdb
